# 树
## n 叉树的存储方法
### 纯结构存储
编号为 `n` 的子节点：$父节点 * n + a$ ($a$ 为子节点从左到右的位置)

### 树结构+链式
树的父节点和子节点可以**数组存储**，也可以用**指针**存储。

### 纯链式存储
使用**左指针**指向子节点，**右指针**指向兄弟节点。

### 其他存储方法
1. 使用一维数组维护每个节点的父节点：**并查集**
2. 存储图（一些性质需要额外维护）

## 树的基本操作
创建、遍历、增加、删除

### 树的遍历
#### 深度优先遍历 DFS
先顺着一侧走到底，然后回退，再走另一个子树。

即：**有子树先建子树**。

这是一个很标准的**递归**。(eg: 八皇后问题、背包问题)

对于枚举一些情况时，深度优先可以使枚举逻辑更加清晰。

深度优先使用**栈**记录已经遍历过的数据。

#### 广度优先遍历
从上到下**逐层**访问，先把这一层的数据访问完，然后再到下一层。

广度优先使用**队列**记录已经遍历的数据。

## 变种
1. 限制节点数：二叉树、三叉树……
2. 限制存储内容：数值大小限制、存储内容关系限制
3. 制定额外操作规则：允许多路搜索……
4. 森林：以一定规则同时操作若干树

## 二叉树
每个节点最多**两个**子节点。二叉树便于维护，结构清晰。

### 二叉排序树
左子树节点小于父节点，右子树大于父节点。

对二叉排序树，按照**左子树-根-右子树**进行深度优先遍历，可以得到**有序数列**。

对任何一个节点查询，时间复杂度都是 $O(log_2n)$。

#### 二叉排序树的退化
举例：输入数据 [1,2,3,4,5,6,7,8,9]，则插入得到的二叉树**全都是右子节点**，那么实际上也就是一个**单链表**，复杂度变成了 $O(n)$。

 
 