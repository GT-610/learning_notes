# STL 容器

数据结构|说明|头文件
:-:|:-:|:-:
向量 `vector`|连续存储元素，底层结构为**数组**, 支持快速随机访问|`<vector>`
字符串 `string`|字符串处理容器|`<string>`
双端队列 `deque`|连续存储的指向不同元素的指针所组成的数组。底层数据结构为一个中央控制器和多个缓冲区，支持首尾元素（中间不能）快速增删，也支持随机访问|`<deque>`


## 迭代器
类似于指针，但**不是线性的**。

### 反向迭代器

## `vector` 容器
### 定义
```cpp
vector<int> v1;
vector<int> v2(10);
vector<double> v3(10, 1.23); // 指定 v3 的 10 个初始元素为 1.23
vector<int> v4(a,a+4); 
```

### 成员函数
* 调用：

    ```cpp
    v1.size();
    v2.resize(5);
    ```

`vector` 有**数组**的性质，所以可以用 `[]` 返回下标元素。

成员函数|作用|注释
:-:|:-:|:-:
`reserve()`|**预分配**内存空间
`resize()`|调整容器大小|缩小之后**被砍掉的地方能访问**，但是会**出错**
`erase()`|删除向量中某个迭代器或者迭代器区间指定的元素|复杂度**可能会很大**
`clear()`|删除所有元素

## `string`
类似于 `vector<char>`

### 定义
```cpp
string s1(from, begin, length);
// from 是内容来源，begin是起始位置，length是截取的长度
```

## `deque` 双端队列容器
连续存储的指向不同元素的指针所组成的数组。底层数据结构为一个中央控制器和多个缓冲区，支持首尾元素（中间不能）快速增删，也支持随机访问。

什么意思呢？


1. "连续存储的指向不同元素的指针所组成的数组"：这句话的意思是，`deque` 的底层实现是由**一系列的指针**组成，这些**指针**分别**指向存储元素的不同位置**。你可以想象 `deque` 是由一系列小的数据块组成，每个数据块可以存储一个或多个元素，而这些小的数据块在内存中可能**并不是连续**的，但是通过**指针**，我们可以方便地访**问到每一个数据块**，从而访问到每一个元素。

    换句话说，`deque` 是用指针把一些内存空间“连接”起来了，就像**火车的车厢**一样，每个车厢的编号不一定是连续的，但是我可以通过**车钩**把这些车厢连接起来，组成一列完整的火车编组。

2. "底层数据结构为一个中央控制器和多个缓冲区"：这句话的意思是，`deque` 的内部实现包括一个中央控制器和多个缓冲区。**中央控制器管理所有的指针**，而**缓冲区则用于存储数据**。你可以把中央控制器看作是一个**火车头**，它知道**如何通过指针找到每一个元素**，而缓冲区则是**车厢**，他们负责**存储数据**（运东西）。

3. "支持首尾元素（中间不能）快速增删，也支持随机访问"：这句话的意思是，`deque` 支持在其两端（即头部和尾部）快速地添加和删除元素，但不支持在中间进行快速的添加和删除操作。同时，deque 也支持随机访问，即你可以**直接访问 deque 中的任何元素**，而**无需像在链表中那样从头开始遍历**。

向 `deque` 插入元素会**很慢**，这是因为 `deque` 的两端插入和删除都是 $O(1)$，但如果你在 `deque` 的中间位置插入元素，那么时间复杂度就会变成 $O(n)$，因为需要移动后面的所有元素。

### 主要成员函数
1. empty()：判断双端队列容器是否为空队。
2. size()：返回双端队列容器中元素个数。
3. push_front(elem)：在队头插入元素elem。
4. push_back(elem)：在队尾插入元素elem。
5. pop_front()：删除队头一个元素。
6. pop_back()：删除队尾一个元素。
7. erase()：从双端队列容器中删除一个或几个元素。
8. clear()：删除双端队列容器中所有元素。
9. 迭代器函数：begin()、end()、rbegin()、rend()。

## `list` 链表
双向链表，可以从任何地方快速插入或删除，元素中间用指针连接，不能随机访问元素。

## 关联容器
1. `set` 和 `multiset`：会自动排序并去除重复元素（本质上是**集合**）
2. `map` 和 `multimap`：效率很高
    
    利用重载可以进行 `pair` 相关操作，从而不需要强制转换。

    `unordered map`

`key` 和 `value` 都是 `pair` 类型。

## `stack` 栈
默认底层容器是 `dque`，但是可以指定。

1|2|3
:-:|:-:|:-:
`top()`|访问栈顶
`pop()`|栈顶出
`push()`|栈顶进

## `queue` 队列
先进先出，不允许顺序遍历

## `priority queue` 优先队列
只能访问第一个元素


# 例题
## P1323
1. 优先队列：输入一个 1，生成对应的两个数后，放回队列里去。最后会生成 $ 6 * 10^4$ 个元素。由于优先队列是**从小到大排好的**，所以输入的数据一定是从小到大的。

2. 直接从头出队就是排好的多位数，用**字符串**保存生成的多位数。

3. 怎么删：在前 $m-1$ 个数位中删去小的那些，留下最大的作为首位。然后在首位后面的 $2$ 个数中，删去小的一个，留下最大的一个即可。

## P5329

## P2031

### 解法一 贪心 $O(n^3)$
1. 先求多少个匹配串
2. 将计数变量 `count` 设置为 0，这样如果不能被分割（找不到），则直接输出 0.
3. 对于每一个串，我们从头开始，一个一个去找（一一个字符一个字符地，复制到另一个串 `answer` 中），如果找到了，计数变量 `count` 加 1，然后清空 `answer`，从后一字符开始继续上述操作，去匹配下一个目标。用 `string::npos` 去匹配一个字符串是否包含另一个串。

### 解法二 动态规划