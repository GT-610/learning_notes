# 输入输出
C 语言把所有的设备当作**文件**。（~~Linux：这个我熟~~）所以所有设备被处理的方式与文件相同。

那么对于输入和输出，是否也是一样的道理呢？答案是肯定的。

在 C 中，**文件指针**是访问文件的方式，文件指针表示指向文件的指针（~~感觉像废话~~）。对于标准输入和输出，它们则是把键盘和屏幕作为设备，使用**标准文件**进行访问的：

标准文件|文件指针|设备
:-:|:-:|:-:
标准输入|`stdin`|键盘
标准输出|`stdout`|屏幕
标准错误|`stderr`|屏幕

实现标准输入和标准输出的函数，就是我们再熟悉不过的 `scanf()` 和 `printf()` 啦。

那么 `scanf()` 和 `printf()` 函数都干了什么呢？

## `scanf()`
```c
int scanf(const char *__restrict__ __format, ...);
```

1. 程序读取格式化字符串 `*format`（就是 `%d`、`%f` 之类的），然后确定需要读取的数据类型和变量。
2. 程序等待用户从标准输入流（一般是键盘）上输入数据。
3. 根据格式化字符串中的类型说明符，程序提取用户输入对应的数据部分，并转换成相应的数据类型。
4. 将转换后的数据存储到指定变量中。

如果 `scanf()` 成功读取并解析所有数据，它会**返回一个非负整数**，表示**成功读取的参数个数**；否则，它可能会返回 **`EOF`** (即 $-1$) 或者**负数**，表示**读取失败**或者**发生错误**。

在 POSIX 标准中，如果一个函数可能会导致线程取消，那么它被称为“取消点”。当线程被取消的时候，它将在取消点处被终止，并且可能会释放一些资源（比如*锁*）以使其他线程可以访问这些资源。

而 `scanf()` 就是这样一个可能的取消点。这是因为 `scanf()` 要等待用户输入数据，可能导致线程在这里被**阻塞**，从而无法响应取消请求。