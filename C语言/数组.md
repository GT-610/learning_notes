# 数组
数据的组合，类型相同且**内存连续**
```c
类型说明符 数组名[数组大小] = {数据, 数据};
```
1. 类型说明符，其实就是之前的基本数据类型
2. 数组名：与变量名命名相同
3. 数组大小：可以说**数字**或者**字符**（还是转换成 ACSCII 码），能存储的数据大小

```c
int a[5] = {1, 2, 3, 4, 5};
```

## 数组的下标
每一个数据都有自己的下标，以定位这一个数据。

下标从 **0** 开始。

数组占内存，内存地址由操作系统随机分配。输出地址的举例：

```c
printf("%p", &a);
```

* 数组定义时可以不给出大小，此时**必须对数组进行初始化**，初始化数据的个数就是数组的大小。

```c
int arr[]; // 错误的
int arr[] = {1, 2, 3}; //OK
```

使用 `sizeof()` 输出某个数组占用的字节数。

## 二维数组
```c
类型说明符 数组名[行大小] [列大小] = {{列数组数据}, {列数组数据}, ...行数组 }; // 逐行赋值

类型说明符 数组名[行大小] [列大小] = {数据, 数据}; // 逐行赋值
```
没有定义的列**会被默认当作 0**。

### 定义规范
```c
int a[4][]; // 错误的
int b[][5]; // 错误的
int c[][3] = {{1,2,3}, {4,5,6}}; //OK (遵循逐行赋值)
```

## n 维数组
推广到 n 维数组，同样适用。

## 字符数组
```c
char a[10];
a[0] = 'a';
```

### 定义
```c
char b[10] = {"abcdefgh"}; //OK
```

### 输出
1. 除了传统输出之外，也可以**当成字符串**输出整个数组：

```c
printf("%s, a");
```

`\0` 表示一个字符串的**结尾**。**每一个字符串的末尾都要有一个 `\0`, 以表示字符串末尾**。

在没有给定数组数据的情况下，以字符串输出未填满的字符数组:
```c
char c[10];
c[0] = 'a';
printf("%s", c);
```

实测用 GCC 编译, 未赋值的部分不会有任何输出。这可能是因为 GCC 会在末尾自动补 `\0`; 但是使用 Visual C++ 编译的时候，由于 VC++ 编译器会把未赋值的部分用 `cc` 填充, `cccc` 在中文编码中正好是 `'烫'`, 导致显示的结果就是 `'烫'`。

2. `gets()` 和 `puts()`
这两个可以用来**输入、输出字符串**。
```c
gets(str5);
puts(str5);
```

### 赋值
如果我们提前给一个位置赋值 `\0`, 则该字符数组会**提前结束**, 在 `\0` 之后的数据, 仍然可以被赋值, 但是**不会被输出**。

也可以用 `scanf()` 对单个位置或整个数组进行赋值操作。

```c
scanf("%s", &str2); // 对整个数组
scanf("%s", &str2[2]); // 对单个位置
```

**汉字也算作字符**。一个汉字占 **2** 个字节。因此, char **不能直接存储汉字**。

```c
char str4[] = "您" // 占 3 个字节, 因为最后一个位置还要存储 \0
```

`\0` 其实也就是**空格**

字符数组也可以定义为多维的。
